Отлично, я полностью переработал файл `Logic.txt` в соответствии с новой архитектурой, где **Nanobot выступает интеллектуальным посредником**. Теперь он отражает полный поток данных `Пользователь -> Nanobot -> API -> БД -> API -> Nanobot -> Пользователь`.

---

# Logic.txt: Логика работы системы с Nanobot

## Основной принцип архитектуры
**Nanobot — это "мозг", API — это "руки и ноги".** Пользователь общается только с мозгом (Nanobot) на естественном языке. Мозг думает, составляет план, но для выполнения любого действия ему нужно обратиться к рукам (API-серверу). Руки имеют исключительный доступ к инструментам (базе данных) и выполняют только разрешенные операции.

## Детальный пошаговый цикл обработки запроса

### ФАЗА 1: ИНИЦИАЦИЯ (Пользователь -> Nanobot)
1. **Пользователь** формулирует запрос через интерфейс:
   - Пишет сообщение или передает голосовое сообщение в Telegram-боте: `"Покажи все датчики с статусом 'неисправен' в корпусе 2"`

2. **Клиент (Telegram-бот/десктоп-приложение)** передает полученный текст или аудио напрямую сервису Nanobot**.
   *Важно: Клиент не должен самостоятельно пытаться понять запрос — его задача только доставить текст "мозгу".*

### ФАЗА 2: АНАЛИЗ И ПЛАНИРОВАНИЕ (Nanobot думает)
3. **Nanobot** получает текстовый запрос пользователя.
4. **Понимание контекста:** Nanobot анализирует запрос, определяя:
   - **Сущности:** Какие объекты упомянуты? (`арендатор`, `датчик`, `корпус`, `этаж`, `помещение`)
   - **Действие:** Что нужно сделать? (`найти`, `показать`, `получить статус`, `отфильтровать`)
   - **Атрибуты:** Какие параметры важны? (`статус=неисправен`, `название_компании=Альфа`)
   - **Тип ответа:** Что нужно вернуть пользователю? (`список`, `одно значение`, `локация на схеме`)

5. **Планирование последовательности API-вызовов:**
   - Nanobot сверяется с описанием доступных инструментов (спецификацией API-методов).
   - Он составляет пошаговый план для получения ответа.
   
   **Пример плана для запроса `"Показать все датчики с статусом 'неисправен' в корпусе 2"`:**
   1. Вызвать `API.get_buildings()` чтобы получить список корпусов и найти ID для "корпус 2"
   2. Вызвать `API.get_sensors(building_id=ID_корпуса_2, status="неисправен")`
   3. Если датчиков много — сгруппировать результаты по этажам для удобного отображения

### ФАЗА 3: ИСПОЛНЕНИЕ ПЛАНА (Nanobot -> API -> БД)
6. **Первый API-вызов:** Nanobot делает запрос к API-серверу, используя формат вызова инструмента:
   ```json
   {
     "action": "get_buildings",
     "parameters": {}
   }
   ```

7. **API-сервер принимает запрос:**
   - Валидирует параметры и права доступа
   - Формирует безопасный SQL-запрос к PostgreSQL
   - Выполняет запрос и получает данные

8. **База данных выполняет запрос** и возвращает результат API-серверу:
   ```json
   [
     {"id": 1, "name": "Корпус 1"},
     {"id": 2, "name": "Корпус 2"},
     {"id": 3, "name": "Корпус 3"}
   ]
   ```

9. **API-сервер возвращает результат Nanobot:**
   ```json
   {
     "status": "success",
     "data": [...],
     "next_possible_actions": ["get_floors", "get_sensors", "get_tenants"]
   }
   ```

### ФАЗА 4: ЦИКЛИЧЕСКОЕ ВЗАИМОДЕЙСТВИЕ (Повторение фаз 2-3)
10. **Nanobot анализирует полученные данные:** Теперь он знает, что ID корпуса 2 = 2.
11. **Составляет следующий шаг плана:** Вызвать `get_sensors` с параметрами `building_id=2, status="неисправен"`.
12. **Второй API-вызов:**
    ```json
    {
      "action": "get_sensors",
      "parameters": {
        "building_id": 2,
        "status": "неисправен"
      }
    }
    ```
13. **API-сервер выполняет сложный SQL-запрос**, объединяя таблицы: `sensors` → `rooms` → `floors` → `buildings`.
14. **Результат от БД:** Список датчиков с их расположением (корпус, этаж, помещение).

### ФАЗА 5: СИНТЕЗ ОТВЕТА (Nanobot формирует финальный ответ)
15. **Nanobot получает все необходимые данные** от API-сервера.
16. **Анализ и форматирование:** Nanobot преобразует структурированные данные в удобочитаемый текст:
    - Группирует датчики по этажам
    - Добавляет пояснения
    - Форматирует в понятный список

17. **Пример сформированного ответа для пользователя:**
    ```
    В корпусе 2 найдено 3 неисправных датчика:
    
    Этаж 3:
    • Помещение 305 (Офис) — датчик дыма DS-305 (последняя проверка: 15.03.2024)
    • Коридор 3-А — тепловой датчик TH-3A (последняя проверка: 10.03.2024)
    
    Этаж 5:
    • Помещение 512 (Склад) — датчик дыма DS-512 (последняя проверка: 12.03.2024)
    
    Рекомендую отправить службе эксплуатации задание на проверку этих датчиков.
    ```

### ФАЗА 6: ВОЗВРАТ РЕЗУЛЬТАТА (Nanobot -> Пользователь)
18. **Nanobot возвращает сформулированный текст** в клиентское приложение.
19. **Клиент отображает результат:**
    - В Telegram: как текстовое сообщение
    - В десктоп-приложении: в основном окне диалога
    - При необходимости: с прикрепленной схемой этажа (запрошенной отдельно через API)

20. **Пользователь получает исчерпывающий ответ** на свой запрос, сформулированный на естественном языке.

## Особые сценарии обработки

### Сценарий 1: Запрос с визуализацией
```
Запрос: "Где офис компании Бета? Покажи на схеме"

План Nanobot:
1. find_tenant("Бета") → получает tenant_id
2. get_rooms(tenant_id=...) → получает список помещений
3. Для каждого помещения: get_floor_plan(room_id=...)
4. Составить ответ с приложением схем

Ответ API для шага 3: Бинарное изображение с выделенным помещением
```

### Сценарий 2: Неоднозначный запрос
```
Запрос: "Где Арендатор 5?"

Действия Nanobot:
1. Определяет неоднозначность: это название компании "Арендатор 5" или арендатор с ID=5?
2. Запрашивает уточнение через API: call_clarification_question()
3. API возвращает шаблон уточняющего вопроса
4. Nanobot задает вопрос пользователю: "Вы имеете в виду компанию с названием 'Арендатор 5' или арендатора с идентификатором 5?"
```

### Сценарий 3: Комплексный аналитический запрос
```
Запрос: "Какие арендаторы находятся рядом с неисправными датчиками?"

План Nanobot:
1. get_sensors(status="неисправен") → список датчиков
2. Для каждого датчика: get_room(sensor_id=...) → информация о помещении
3. Для каждого помещения: get_adjacent_rooms(room_id=...) → соседние помещения
4. Для каждого соседнего помещения: get_tenant(room_id=...) → арендаторы
5. Анализ, группировка и составление отчета
```

## Обработка ошибок и граничные случаи
1. **Нет данных:** Если API возвращает пустой результат, Nanobot формулирует вежливый ответ: "По вашему запросу ничего не найдено. Попробуйте уточнить параметры поиска."
2. **Ошибка API:** При получении ошибки от API (например, 404 или 500), Nanobot сообщает: "Произошла техническая ошибка при обработке запроса. Пожалуйста, повторите попытку позже."
3. **Слишком сложный запрос:** Если запрос требует более 5 последовательных вызовов API, Nanobot может предложить упростить запрос или разбить его на несколько.
4. **Конфиденциальность данных:** Nanobot никогда не раскрывает в ответе технические детали (ID, SQL-запросы), только бизнес-информацию в удобной форме.

## Преимущества такого подхода
1. **Безопасность:** Прямой доступ к БД есть только у API-сервера
2. **Гибкость:** Легко менять бизнес-логику на API-сервере без изменения Nanobot
3. **Масштабируемость:** Nanobot и API-сервер можно масштабировать независимо
4. **Тестируемость:** Каждый компонент можно тестировать отдельно
5. **Обслуживание:** Можно обновлять модель Nanobot без остановки всей системы

Эта логика обеспечивает безопасное, эффективное и естественное взаимодействие пользователя со сложной системой учета помещений и датчиков.
